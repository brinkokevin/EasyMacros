[{"title":"Custom Widgets","type":0,"sectionRef":"#","url":"/EasyMacros/docs/CustomWidgets","content":"Custom Widgets While Easy Macros focuses on simplicity and ease of use, it also provides a way to create custom widgets for more advanced use cases. To create a custom widget, we need to use the create, widget, and useInstance functions from the api object. Here is an example of how you can create a custom button widget: -- ServerStorage/ColorButton.lua local MacroTypes = require(game.ServerStorage.MacroTypes) local theme = settings().Studio.Theme return MacroTypes.widget(function(text: string, color: Color3) local clicked, setClicked = Runtime.useState(false) local refs = MacroTypes.useInstance(function(ref) MacroTypes.create(&quot;TextButton&quot;, { [ref] = &quot;button&quot;, BackgroundColor3 = theme:GetColor(Enum.StudioStyleGuideColor.Button), TextColor3 = theme:GetColor(Enum.StudioStyleGuideColor.ButtonText), Size = UDim2.new(1, 0, 0, 30), Activated = function() setClicked(true) end, }) return ref.button end) refs.button.Text = tostring(text) refs.button.BackgroundColor3 = color local handle = { clicked = function() if clicked then setClicked(false) return true end return false end, } return handle end) Using the custom widget is the same as built-in widgets. local MacroTypes = require(game.ServerStorage.MacroTypes) local customButton = require(game.ServerStorage.ColorButton) local function render(api: MacroTypes.api) local button = customButton(&quot;Red button&quot;, Color3.fromRGB(255, 0, 0)) end ","keywords":""},{"title":"How macro works","type":0,"sectionRef":"#","url":"/EasyMacros/docs/Render","content":"","keywords":""},{"title":"The render function​","type":1,"pageTitle":"How macro works","url":"/EasyMacros/docs/Render#the-render-function","content":"The render function is the heart of your macro. It's called every frame, and it's where you define the UI components of your macro. The render function receives an api object as an argument, which provides functions for creating UI components. local function render(api) api.label(&quot;Hello, World!&quot;) end  Easy Macros uses a modified version of Plasma, an immediate mode UI library. Here are some important bits from the Plasma documentation. "},{"title":"What is immediate mode?​","type":1,"pageTitle":"How macro works","url":"/EasyMacros/docs/Render#what-is-immediate-mode","content":"Plasma is an immediate mode UI library, as opposed to retained mode. In a retained mode model, you might make a button and connect a clicked event, with code that is invoked when the event happens. The button is retained in the DataModel, and to change the text on it, you need to store a reference to it. But under an immediate mode model, you show the button and check if it's been clicked immediately, and you do that every single frame (60 times per second). There's no need for a clicked event or to store a reference to the button. As another example, let's say you had a window that you only wanted to be shown when it was visible. In retained mode, you would create the window and store a reference to the window. When the button to toggle visibility is toggled, you use the reference to the window to make it visible or not. In immediate mode, it's much simpler: you just check if the window should be rendered with an if statement and render the window inside the if statement. That's it: if the window wasn't supposed to be rendered, you just never call the code to render the window. "},{"title":"Advantages​","type":1,"pageTitle":"How macro works","url":"/EasyMacros/docs/Render#advantages","content":"The main advantage of immediate mode is that code becomes vastly simpler: You never need to have any on-click handlers and callbacks that disrupt your code flow. You don't have to worry about a lingering callback calling something that is gone. Your GUI code can easily live in a simple function (no need for an object just for the UI). You don't have to worry about the world and GUI state being out-of-sync (i.e., the GUI showing something outdated), because the GUI isn't storing any state - it is showing the latest state immediately. In other words, a whole lot of code, complexity, and bugs are gone, and you can focus your time on something more interesting than writing GUI code. To learn more, check out the Plasma documentation. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/EasyMacros/docs/intro","content":"","keywords":""},{"title":"Installing the plugin​","type":1,"pageTitle":"Getting Started","url":"/EasyMacros/docs/intro#installing-the-plugin","content":"To install the plugin, you need to first purchase it on the Roblox Creator Store. Get the Easy Macros Plugin on the Roblox Creator Store.Open Roblox Studio and install the plugin. "},{"title":"Using the plugin​","type":1,"pageTitle":"Getting Started","url":"/EasyMacros/docs/intro#using-the-plugin","content":"&quot;The plugin provides you with two buttons in the Plugins tab of Roblox Studio.  Open Menu - Toggles the main menu of the plugin.Create Template - Creates a new Template.macro ModuleScript. "},{"title":"Creating a new macro​","type":1,"pageTitle":"Getting Started","url":"/EasyMacros/docs/intro#creating-a-new-macro","content":"To create a macro, first create a new ModuleScript and name it with the .macro suffix, like MyMacro.macro. Alternatively, you can use the Create Template button in the Plugins tab to make a new macro. "},{"title":"Macro Template​","type":1,"pageTitle":"Getting Started","url":"/EasyMacros/docs/intro#macro-template","content":"Here is a basic macro template. Each macro module must return a table with the following fields: title: The title of the macrolayoutOrder: The order in which the macro appears in the menurender: The function that defines the UI components of the macro return { title = &quot;My Macro&quot;, layoutOrder = 1, render = function(api) -- Your macro code here end }  "},{"title":"Examples","type":0,"sectionRef":"#","url":"/EasyMacros/docs/Examples","content":"","keywords":""},{"title":"All Widgets​","type":1,"pageTitle":"Examples","url":"/EasyMacros/docs/Examples#all-widgets","content":"This macro demonstrates all the widgets available. If you would like to see more widgets added, feel free to open an issue or dm me on discord @brinkokevin. local MacroTypes = require(game.ServerStorage.MacroTypes) local isChecked = false local function render(api: MacroTypes.api) -- Simple label api.label(&quot;Hello, World!&quot;) -- Simple heading api.heading(&quot;Hello, World!&quot;) -- Heading with custom font api.heading(&quot;Hello, World!&quot;, { font = Font.fromName(&quot;Bangers&quot;, Enum.FontWeight.ExtraBold, Enum.FontStyle.Normal), }) api.heading(&quot;Hello, World!&quot;, { font = Enum.Font.ArimoBold, }) -- Error message api.error(&quot;Failed to execute macro!&quot;) -- Button local button = api.button(&quot;Hello, World!&quot;) if button:clicked() then print(&quot;Button was clicked!&quot;) end -- Uncontrolled checkbox local checkbox = api.checkbox(&quot;Uncontrolled checkbox&quot;) if checkbox:clicked() then print(&quot;Checkbox was clicked, current state: &quot; .. tostring(checkbox:getValue())) end -- Controlled checkbox local controlledCheckbox = api.checkbox(&quot;Controlled checkbox&quot;, { checked = isChecked, }) if controlledCheckbox:clicked() then isChecked = not isChecked print(&quot;Controlled checkbox was clicked, current state: &quot; .. tostring(isChecked)) end -- Disabled checkbox api.checkbox(&quot;Disabled checkbox&quot;, { checked = isChecked, disabled = true, }) -- Simple Number input local ageInput = api.numberinput(&quot;Age&quot;) if ageInput:valueChanged() then print(&quot;New age: &quot; .. tostring(ageInput:getValue())) end -- Number input with constraints local numberInput = api.numberinput(&quot;Radius&quot;, { default = 30, min = 0, max = 100, }) if numberInput:valueChanged() then print(&quot;New value: &quot; .. tostring(numberInput:getValue())) end -- String input with no default value local stringInput = api.stringinput(&quot;String Input&quot;) if stringInput:valueChanged() then print(&quot;New string: &quot; .. tostring(stringInput:getValue())) end -- String input with default value local defaultStringInput = api.stringinput(&quot;String Input with default value&quot;, { default = &quot;Hello, World!&quot;, }) if defaultStringInput:valueChanged() then print(&quot;New string: &quot; .. tostring(defaultStringInput:getValue())) end end return { title = &quot;Example: All Widgets&quot;, layoutOrder = 5, render = render, }   "},{"title":"Load Character​","type":1,"pageTitle":"Examples","url":"/EasyMacros/docs/Examples#load-character","content":"Load Character is a simple macro that loads a character into the workspace. It's a good example of how to use the api object to create StringInput, Checkbox and a Button component. -- MacroTypes provides the API types to luau, if you don't care about types you don't have to use it local MacroTypes = require(game.ServerStorage.MacroTypes) -- ChangeHistoryService is used to record changes in studio, this allows us to undo the changes we make local ChangeHistoryService = game:GetService(&quot;ChangeHistoryService&quot;) local Camera = workspace.CurrentCamera -- Insert Character is a helper function for our macro, it's not related to Easy Macros local function insertCharacter(username: string, isR6: boolean) -- Start recording the changes we make to the workspace local id = ChangeHistoryService:TryBeginRecording(&quot;LoadCharacter&quot;) -- Get the userId of the player local userId = game.Players:GetUserIdFromNameAsync(username) -- Get the humanoid description of the player local humanoidDescription = game.Players:GetHumanoidDescriptionFromUserId(userId) -- Create a model from the humanoid description local rigType = isR6 and Enum.HumanoidRigType.R6 or Enum.HumanoidRigType.R15 local model = game.Players:CreateHumanoidModelFromDescription(humanoidDescription, rigType) model:PivotTo(CFrame.new((Camera.CFrame * CFrame.new(0, 0, -25)).Position)) model.Name = username model.Parent = workspace -- Finish recording the changes we made if id then ChangeHistoryService:FinishRecording(id, Enum.FinishRecordingOperation.Commit) end end -- Render function is called every frame, it's where you define the UI components of your macro local function render(api: MacroTypes.api) -- Render the UI components local usernameInput = api.stringinput(&quot;Username&quot;, { default = &quot;brinkokevin&quot;, }) local r6Checkbox = api.checkbox(&quot;Create R6 character&quot;) local insertButton = api.button(&quot;Insert Character&quot;) -- clicked is a function that returns true if the button was clicked -- Once clicked is read, it resets to false until the button is clicked again if insertButton:clicked() then -- Get the values of the UI components local username = usernameInput:getValue() local isR6 = r6Checkbox:getValue() -- We use task.spawn to avoid yielding the render function, -- since loading the character can take a moment -- and we are not allowed to yield inside the render function task.spawn(insertCharacter, username or &quot;brinkokevin&quot;, isR6) end end return { -- The title of the macro title = &quot;Example: Load Character&quot;, -- The order in which the macro appears in the menu layoutOrder = 2, -- The function that defines the UI components of the macro render = render, }   "},{"title":"More Examples Coming Soon​","type":1,"pageTitle":"Examples","url":"/EasyMacros/docs/Examples#more-examples-coming-soon","content":"If you have a macro you'd like to share, feel free to submit a pull request to add it to the documentation! If you are not familiar with github, you can also dm me on discord @brinkokevin "},{"title":"EasyMacros","type":0,"sectionRef":"#","url":"/EasyMacros/api/EasyMacros","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#functions","content":" "},{"title":"label​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#label","content":"widgets &lt;/&gt; EasyMacros.label( text: string-- The text to display on the label ) → () Displays text api.label(&quot;Hello, World!&quot;)   "},{"title":"heading​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#heading","content":"widgets &lt;/&gt; EasyMacros.heading( text: string,-- The text to display on the label options: {font: Enum.Font | Font }? ) → () Displays text but bigger! Optionally, you can change the font. -- Heading with default font api.heading(&quot;Hello, World!&quot;) -- Heading with custom font api.heading(&quot;Hello, World!&quot;, { font = Enum.Font.SourceSansBold })   "},{"title":"error​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#error","content":"widgets &lt;/&gt; EasyMacros.error( text: string-- The error message to display. ) → () Displays an error message api.error(&quot;Invalid username!&quot;)   "},{"title":"button​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#button","content":"widgets &lt;/&gt; EasyMacros.button( label: string-- The label for the button ) → ButtonHandle A text button. Returns a table with the following functions: clicked, a function you can call to check if the button was clicked this frame local button = api.button(&quot;Hello, World!&quot;) if button:clicked() then print(&quot;Button was clicked!&quot;) end   "},{"title":"checkbox​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#checkbox","content":"widgets &lt;/&gt; EasyMacros.checkbox( text: string,-- The label for the checkbox options: { checked: boolean?, disabled: boolean? }? ) → CheckboxHandle Creates a checkbox. Returns a table with the following functions: getValue: A function to check if the checkbox is checked. clicked: A function to check if the checkbox was clicked this frame. -- We define variable outside of the render function to keep the state between render frames -- Optionally, you can use `useState` hook to keep the state between render frames local isChecked = false local function render(api) -- Uncontrolled checkbox local checkbox = api.checkbox(&quot;Uncontrolled checkbox&quot;) if checkbox:clicked() then print(&quot;Checkbox was clicked, current state: &quot; .. tostring(checkbox:getValue())) end -- Controlled checkbox local controlledCheckbox = api.checkbox(&quot;Controlled checkbox&quot;, { checked = isChecked }) if controlledCheckbox:clicked() then isChecked = not isChecked print(&quot;Controlled checkbox was clicked, current state: &quot; .. tostring(isChecked)) end -- Disabled checkbox api.checkbox(&quot;Disabled checkbox&quot;, { checked = isChecked, disabled = true }) end   "},{"title":"numberinput​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#numberinput","content":"widgets &lt;/&gt; EasyMacros.numberinput( label: string,-- The label for the input options: { default: string?, min: number?, max: number? }? ) → NumberInputHandle Creates an input field for numbers. Optionally, you can provide a default value and min/max constraints. Returns a table with the following functions: getValue: A function to get the current value, nil if invalid. valueChanged: A function to check if the value has changed since the last frame. -- Simple Number input local ageInput = api.numberinput(&quot;Age&quot;) if ageInput:valueChanged() then -- Print then new value print(ageInput:getValue()) end -- Number input with constraints local numberInput = api.numberinput(&quot;Radius&quot;, { default = 30, min = 0, max = 100, }) if numberInput:valueChanged() then -- Print then new value, clamped between 0 and 100 print(numberInput:getValue()) end   "},{"title":"stringinput​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#stringinput","content":"widgets &lt;/&gt; EasyMacros.stringinput( label: string,-- The label for the input options: {default: string?}? ) → StringInputHandle Creates an input field for text. Optionally, you can provide a default value. Returns a table with the following functions: getValue: A function to get the current value, nil if invalid. valueChanged: A function to check if the value has changed since the last frame. -- String input with no default value local stringInput = api.stringinput(&quot;String Input&quot;) if stringInput:valueChanged() then -- Print then new value print(stringInput:getValue()) end -- String input with default value local defaultStringInput = api.stringinput(&quot;String Input with default value&quot;, { default = &quot;Hello, World!&quot;, }) if defaultStringInput:valueChanged() then -- Print then new value print(defaultStringInput:getValue()) end   "},{"title":"useState​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#useState","content":"hooks &lt;/&gt; EasyMacros.useState( initialValue: T-- The value this hook returns if the set callback has never been called ) → ( T,-- The previously set value, or the initial value if none has been set (newValue: T) → ()-- A function which when called stores the value in this hook for the next run ) Returns a state value and an update function. local function render(api) local count, setCount = api.useState(0) local button = api.button(&quot;Increase count&quot;) if button:clicked() then setCount(count + 1) end api.label(&quot;Count: &quot; .. count) end   "},{"title":"useEffect​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#useEffect","content":"hooks &lt;/&gt; EasyMacros.useEffect( callback: () → () | () → () → (),-- A callback function that optionally returns a cleanup function ...: any-- Dependencies ) → () useEffect takes a callback as a parameter which is then only invoked if passed dependencies are different from the last time this function was called. The callback is always invoked the first time this code path is reached. If no dependencies are passed, the callback only runs once. This function can be used to skip expensive work if none of the dependencies have changed since the last run. For example, you might use this to set a bunch of properties in a widget if any of the inputs change. local function render(api) local instanceCount, setInstanceCount = api.useState(0) api.label(&quot;Workspace instance count: &quot; .. instanceCount) -- This function will only run once when the macro is first rendered -- It will disconnect the event listeners when the macro is removed api.useEffect(function() local function updateInstanceCount() setInstanceCount(#workspace:GetDescendants()) end local childAdded = workspace.ChildAdded:Connect(updateInstanceCount) local childRemoved = workspace.ChildRemoved:Connect(updateInstanceCount) return function() childAdded:Disconnect() childRemoved:Disconnect() end end) -- This function will run every time the instanceCount changes api.useEffect(function() print(&quot;Instance count changed to: &quot; .. instanceCount) end, instanceCount) end   "},{"title":"useInstance​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#useInstance","content":"hooks &lt;/&gt; EasyMacros.useInstance( creator: (ref: {}) → ( Instance , Instance? )-- A callback which creates the widget and returns it ) → Instance -- Returns the instance returned by creator useInstance takes a callback which should be used to create the initial UI for the widget. The callback is only ever invoked on the first time this widget runs and never again. The callback should return the instance it created. The callback can optionally return a second value, which is the instance where children of this widget should be placed. Otherwise, children are placed in the first instance returned. useInstance returns the ref table that is passed to it. You can use this to create references to objects you want to update in the widget body.  "},{"title":"useKey​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#useKey","content":"hooks &lt;/&gt; EasyMacros.useKey(key: string) → () Specify a key by which to store all future state in this scope. This is similar to React's key prop. This is important to use to prevent state from one source being still being applied when it should actually reset.  "},{"title":"create​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#create","content":"utilities &lt;/&gt; EasyMacros.create( className: string,-- The class name of the Instance to create props: CreateProps ) → Instance -- The created instance A function that creates an Instance tree. CreateProps is a table: String keys are interpreted as properties to set children key is interpreted as an array of children to parent to the instance Function values are interpreted as event handlers Table keys can be used to get references to instances deep in the tree, the value becomes the key in the table This function doesn't do anything special. It just creates an instance. api.create(&quot;Frame&quot;, { BackgroundTransparency = 1, Name = &quot;Checkbox&quot;, children = { api.create(&quot;TextButton&quot;, { BackgroundColor3 = Color3.fromRGB(54, 54, 54), Size = UDim2.new(0, 30, 0, 30), Activated = function() setClicked(true) end, children = { api.create(&quot;UICorner&quot;, { CornerRadius = UDim.new(0, 8), }), }, }), }, }) Getting references to instances deep in a tree: local ref = {} api.create(&quot;Frame&quot;, { api.create(&quot;TextButton&quot;, { [ref] = &quot;button&quot;, Text = &quot;hi&quot; }) }) print(ref.button.Text) --&gt; hi This pairs well with useInstance hook: local function label(api, text: string) local ref = api.useInstance(function(refs) return api.create(&quot;TextLabel&quot;, { [ref] = &quot;button&quot;, }) end) ref.button.Text = text end   "},{"title":"widget​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#widget","content":"utilities &lt;/&gt; EasyMacros.widget( fn: (...: T) → ()-- The widget function ) → (...: T) → ()-- A function which can be called to create the widget This function takes a widget function and returns a function that automatically starts a new scope when the function is called. Here is what the label widget looks like under the hood: return api.widget(function(text: string) local refs = api.useInstance(function(ref) api.create(&quot;TextLabel&quot;, { [ref] = &quot;label&quot;, BackgroundTransparency = 1, Font = Enum.Font.SourceSans, TextColor3 = theme:GetColor(Enum.StudioStyleGuideColor.MainText), TextSize = 20, RichText = true, TextWrapped = true, AutomaticSize = Enum.AutomaticSize.Y, Size = UDim2.new(1, 0, 0, 0), }) return ref.label end) refs.label.Text = tostring(text) end)   "},{"title":"scope​","type":1,"pageTitle":"EasyMacros","url":"/EasyMacros/api/EasyMacros#scope","content":"utilities &lt;/&gt; EasyMacros.scope( fn: (...: T) → (), ...: T-- Additional parameters to callback ) → () Begins a new scope. The callback is invoked immediately. Beginning a new scope associates all further API calls with a nested scope inside this one. "}]